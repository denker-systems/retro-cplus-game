/**
 * @file GLContext.cpp
 * @brief OpenGL context management implementation
 */
#include "GLContext.h"
#include <iostream>

namespace engine {

GLContext::~GLContext() {
    shutdown();
}

GLContext::GLContext(GLContext&& other) noexcept
    : m_window(other.m_window)
    , m_context(other.m_context)
    , m_initialized(other.m_initialized) {
    other.m_window = nullptr;
    other.m_context = nullptr;
    other.m_initialized = false;
}

GLContext& GLContext::operator=(GLContext&& other) noexcept {
    if (this != &other) {
        shutdown();
        m_window = other.m_window;
        m_context = other.m_context;
        m_initialized = other.m_initialized;
        other.m_window = nullptr;
        other.m_context = nullptr;
        other.m_initialized = false;
    }
    return *this;
}

bool GLContext::initialize(SDL_Window* window, int majorVersion, int minorVersion) {
    if (m_initialized) {
        std::cerr << "GLContext: Already initialized" << std::endl;
        return false;
    }
    
    if (!window) {
        std::cerr << "GLContext: Invalid window pointer" << std::endl;
        return false;
    }
    
    m_window = window;
    
    // Note: GL attributes should be set BEFORE window creation in Game.cpp
    // Only set them here as fallback if not already set
    int currentMajor = 0;
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &currentMajor);
    if (currentMajor == 0) {
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, majorVersion);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minorVersion);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
    }
    
    // Create OpenGL context
    m_context = SDL_GL_CreateContext(m_window);
    if (!m_context) {
        std::cerr << "GLContext: Failed to create OpenGL context: " << SDL_GetError() << std::endl;
        return false;
    }
    
    // Make context current
    if (SDL_GL_MakeCurrent(m_window, m_context) < 0) {
        std::cerr << "GLContext: Failed to make context current: " << SDL_GetError() << std::endl;
        SDL_GL_DeleteContext(m_context);
        m_context = nullptr;
        return false;
    }
    
    // Initialize GLEW
    glewExperimental = GL_TRUE;
    GLenum glewError = glewInit();
    if (glewError != GLEW_OK) {
        std::cerr << "GLContext: Failed to initialize GLEW: " << glewGetErrorString(glewError) << std::endl;
        SDL_GL_DeleteContext(m_context);
        m_context = nullptr;
        return false;
    }
    
    // Clear any OpenGL error generated by GLEW initialization
    while (glGetError() != GL_NO_ERROR) {}
    
    // Enable VSync by default
    setVSync(true);
    
    // Log OpenGL info
    std::cout << "GLContext: OpenGL " << getGLVersion() << std::endl;
    std::cout << "GLContext: GLSL " << getGLSLVersion() << std::endl;
    std::cout << "GLContext: Renderer " << getRenderer() << std::endl;
    
    m_initialized = true;
    return true;
}

void GLContext::shutdown() {
    if (m_context) {
        SDL_GL_DeleteContext(m_context);
        m_context = nullptr;
    }
    m_window = nullptr;
    m_initialized = false;
}

void GLContext::swapBuffers() {
    if (m_window) {
        SDL_GL_SwapWindow(m_window);
    }
}

bool GLContext::makeCurrent() {
    if (m_window && m_context) {
        return SDL_GL_MakeCurrent(m_window, m_context) == 0;
    }
    return false;
}

bool GLContext::setVSync(bool enabled) {
    // 0 = immediate, 1 = vsync, -1 = adaptive vsync
    int interval = enabled ? 1 : 0;
    if (SDL_GL_SetSwapInterval(interval) < 0) {
        std::cerr << "GLContext: Failed to set VSync: " << SDL_GetError() << std::endl;
        return false;
    }
    return true;
}

const char* GLContext::getGLVersion() const {
    return reinterpret_cast<const char*>(glGetString(GL_VERSION));
}

const char* GLContext::getGLSLVersion() const {
    return reinterpret_cast<const char*>(glGetString(GL_SHADING_LANGUAGE_VERSION));
}

const char* GLContext::getRenderer() const {
    return reinterpret_cast<const char*>(glGetString(GL_RENDERER));
}

} // namespace engine
